<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>api API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>api</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import flask
import uuid
import os
from flask import request, jsonify
from functions import getFileBase64, getOcr, readTextFileContents, getSuggestedTags, getDictKey, fileExists, generateSessionToken
from conn import Conn
from classifier import Classifier
from strings import *

app = flask.Flask(__name__)
app.config[&#34;DEBUG&#34;] = True
app.config[&#39;CORS_HEADERS&#39;] = &#39;Content-Type&#39;

_labelAll = [&#34;negative&#34;, &#34;neutral&#34;, &#34;positive&#34;]


def getRequiredParameters(_request, **kwargs):
    &#34;&#34;&#34;
    Checks if the request body contains all the required parameters. Uses a hack with **kwargs.

    :param _request: The request body.
    :param kwargs: The required parameters.
    :return: Returns False and the parameter that was missing if there was missing data. Returns True and a dict containing all the parameter name and their values if successful.
    &#34;&#34;&#34;
    if hasattr(_request, &#34;json&#34;):
        requestReceived = _request.json
    else:
        requestReceived = _request

    for key, value in kwargs.items():
        kwargs[key] = requestReceived.get(key)

    if None in kwargs.values():  # if one parameter is missing
        return [False, getDictKey(kwargs, kwargs.get(None))]
    else:
        return [True, kwargs]


@app.route(&#39;/api/login&#39;, methods=[&#39;POST&#39;])
def login():
    &#34;&#34;&#34;
    Checks user&#39;s credentials and if successful, returns a session token lasting 3 hours for the user.

    Required params:\n
    -action = &#39;login&#39;\n
    -username\n
    -userpw\n

    :return: A session token and 201 if successful.
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    chkMissingData, data = getRequiredParameters(request, action=&#39;&#39;, username=&#39;&#39;, userpw=&#39;&#39;)

    if not chkMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    # assume password sent is always unhashed, unless specified
    data[&#39;hashed&#39;] = False
    if request.json[&#39;hashed&#39;] is not None and request.json[&#39;hashed&#39;]:
        data[&#39;hashed&#39;] = request.json[&#39;hashed&#39;]

    con = Conn()
    sessionToken = generateSessionToken()

    if con.userLogin(data[&#39;username&#39;], data[&#39;userpw&#39;], sessionToken, data[&#39;hashed&#39;]) == -1:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: False,
                     &#39;message&#39;: &#34;User login failed.&#34;},
                &#39;data&#39;: None
            }), 403

    return jsonify(
        {
            &#39;status&#39;: RETURN_SUCCESS_STATUS,
            &#39;data&#39;: {&#39;token&#39;: sessionToken}
        }), 201


@app.route(&#39;/api/registration&#39;, methods=[&#39;POST&#39;])
def register():
    &#34;&#34;&#34;
    Registers a user and creates a model for them.

    Required params:\n
    -action = &#39;register&#39;\n
    -username\n
    -userpw\n
    -email\n
    -firstname\n
    -lastname\n
    :return: Returns the modelID and 201 for them.
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    chkMissingData, data = getRequiredParameters(request, action=&#39;&#39;, username=&#39;&#39;, userpw=&#39;&#39;, email=&#39;&#39;,
                                                 firstname=&#39;&#39;, lastname=&#39;&#39;)

    if not chkMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()

    if data[&#39;action&#39;] != &#39;register&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for registration.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    username = data[&#34;username&#34;]
    password = data[&#34;userpw&#34;]  # assume plain password sent over https

    if con.usernameExists(username):
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Username already exists.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    userID = con.registerUser(username=username, pwd=password, firstName=data[&#39;firstname&#39;], lastName=data[&#39;lastname&#39;],
                              email=data[&#39;email&#39;], usePwHash=False)

    # make new model
    model = Classifier(makeNewModel=True)
    mid = con.addNewModel(userID=str(userID), modelName=model.modelName)

    # if error during user creation
    if userID == -1 or mid == -1:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Server encountered error with user registration. Please try again later&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 500

    # if user registration is ok
    return jsonify(
        {
            &#39;status&#39;: RETURN_SUCCESS_STATUS,
            &#39;data&#39;: {&#39;mid&#39;: mid}
        }), 201


@app.route(&#39;/api/retrain&#39;, methods=[&#39;PUT&#39;])
def retrain():
    &#34;&#34;&#34;
    Used to retrain the model.

    Required params:\n
    -action = &#39;retrain&#39;\n
    -stoken =&gt; the session token \n
    -data =&gt; a list of trainingID that will be deleted\n

    :return: A success message and 200.
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    chkMissingData, data = getRequiredParameters(request, stoken=&#39;&#39;, action=&#39;&#39;, data=&#39;&#39;)

    if not chkMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    userID = con.checkToken(data[&#34;stoken&#34;])

    if userID == -1:
        return jsonify(INVALID_SESSION_TOKEN), 403

    if data[&#39;action&#39;] != &#39;retrain&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for retraining.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if type(data[&#39;data&#39;]) != list:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Bad data. Data in the \&#39;data\&#39; field must be sent as list.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    # get old model info
    oldModelID, oldModelName = con.getModelInfo(str(userID))

    if not con.removeTraining(oldModelID, data[&#39;data&#39;]):
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Internal server encountered. Please try again.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 500

    availableTraining = con.getAvailableTraining(oldModelID)

    # make a new model
    model = Classifier(makeNewModel=True)
    for eachData in availableTraining:
        model.train(text=eachData[2], sentiment=eachData[3], fromDB=True)

    # update db with new model info
    if not con.updateModelInfo(oldModelID, modelName=model.modelName):
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Internal server error when updating the resource.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 500

    if not oldModelName.endswith(PICKLE_FILE_EXTENSION):
        oldModelName += PICKLE_FILE_EXTENSION

    os.remove(os.path.join(os.path.dirname(__file__), &#39;Models/&#39; + oldModelName))

    return jsonify(
        {
            &#39;status&#39;:
                {&#39;message&#39;: &#39;Model successfully retrained.&#39;,
                 &#39;error&#39;: False},
            &#39;data&#39;: None
        }), 200


@app.route(&#39;/api/training&#39;, methods=[&#39;POST&#39;])
def getTrainingData():
    &#34;&#34;&#34;
    Gets all the available training data.

    Required params:\n
    -action = &#39;getData&#39;\n
    -stoken\n

    :return: Returns the training data for that user and 200.
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    chkMissingData, data = getRequiredParameters(request, stoken=&#39;&#39;, action=&#39;&#39;)

    if not chkMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    userID = con.checkToken(data[&#34;stoken&#34;])

    if userID == -1:
        return jsonify(INVALID_SESSION_TOKEN), 403

    if data[&#39;action&#39;] != &#39;getData&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for retrieving training data.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    modelID, modelName = con.getModelInfo(str(userID))

    availableTraining = con.getAvailableTraining(modelID)

    formattedTraining = list()
    for item in availableTraining:
        trainingDict = dict()
        trainingDict[&#34;id&#34;] = item[0]
        trainingDict[&#34;rawText&#34;] = item[1]
        trainingDict[&#34;sentiment&#34;] = item[3]
        trainingDict[&#34;tags&#34;] = item[4]
        trainingDict[&#34;dateTrained&#34;] = item[5]
        formattedTraining.append(trainingDict)

    return jsonify(
        {
            &#39;status&#39;: RETURN_SUCCESS_STATUS,
            &#39;data&#39;:
                {
                    &#39;availableTraining&#39;: formattedTraining}
        }), 200


@app.route(&#39;/api/ocr&#39;, methods=[&#39;POST&#39;])
def getOCRtext():
    &#34;&#34;&#34;
    Gets extracted text for an image.

    Required params:\n
    -action = &#39;ocr&#39;\n
    -stoken\n
    -datatype = blob\n
    -data =&gt; list (if multiple) or string (if single)\n

    :return: Returns the extracted text and 200.
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    noMissingData, data = getRequiredParameters(request, stoken=&#39;&#39;, datatype=&#39;&#39;, data=&#39;&#39;, action=&#39;&#39;)

    if not noMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    userID = con.checkToken(data[&#39;stoken&#39;])

    if userID == -1:
        return jsonify(INVALID_SESSION_TOKEN), 403

    if data[&#39;action&#39;] != &#39;ocr&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for getting OCR text.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if data[&#39;datatype&#39;] != &#39;blob&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong request. This endpoint is only for blobs.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if type(data[&#39;data&#39;]) != list and type(data[&#39;data&#39;]) != str:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong data type for \&#39;data\&#39; field. Accepted types are str or list.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    if type(data[&#39;data&#39;]) == list:  # if multiple files
        status, files = [], []
        for item in data[&#39;data&#39;]:
            filename = str(uuid.uuid4())  # generate temp file name
            iferr, retval = getFileBase64(item, filename, userID)
            status.append(iferr)
            files.append(retval)

        if False in status:  # if any error during converting the file
            return jsonify(
                {
                    &#39;status&#39;:
                        {&#39;error&#39;: False,
                         &#39;message&#39;: ERRORFILEEXTEN}
                }), 400

        ocrtext = []
        for eachFile in files:
            ocrtext.append(getOcr(eachFile))
            os.remove(eachFile)

        return jsonify(
            {
                &#39;status&#39;: RETURN_SUCCESS_STATUS,
                &#39;data&#39;:
                    {
                        &#39;ocrtext&#39;: ocrtext,
                        &#39;type&#39;: &#39;list&#39;}
            }), 200

    elif type(data[&#39;data&#39;]) == str:  # if single file
        filename = str(uuid.uuid4())  # generate temp file name
        status, filepath = getFileBase64(request.json[&#39;data&#39;], filename, userID)

        if not status:
            # if error during converting the file
            return jsonify(
                {
                    &#39;status&#39;:
                        {&#39;error&#39;: False,
                         &#39;message&#39;: ERRORFILEEXTEN}
                }), 400

        ocrtext = getOcr(filepath)
        os.remove(filepath)  # remove temp file
        return jsonify(
            {
                &#39;status&#39;: RETURN_SUCCESS_STATUS,
                &#39;data&#39;:
                    {
                        &#39;ocrtext&#39;: ocrtext,
                        &#39;type&#39;: &#39;str&#39;}
            }), 200


@app.route(&#39;/api/suggestedTags&#39;, methods=[&#39;GET&#39;])
def getTags():
    &#34;&#34;&#34;
    Gets suggested tags.

    Required params:\n
    -tags =&gt; list of tags, separated by a delimiter (default commas)
    -mid =&gt; model ID

    Optional params:\n
    -howMany =&gt; default 5
    -delim =&gt; default comma, used to separate the tags
    :return: Suggested tags based on previous taught knowledge.
    &#34;&#34;&#34;
    request.get_data()
    if request.args is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;No data is received.&#34;},
                &#39;data&#39;: None
            }), 400

    userTags = request.args.get(&#34;tags&#34;)
    modelID = request.args.get(&#34;mid&#34;)
    returnNumber = request.args.get(&#34;howMany&#34;) if request.args.get(&#34;howMany&#34;) is not None and int(
        request.args.get(&#34;howMany&#34;)) &gt; 0 else DEFAULT_RETURN_SUGGESTED_TAGS
    delim = request.args.get(&#34;delim&#34;) if request.args.get(&#34;delim&#34;) is not None else &#34;,&#34;

    if userTags is None or modelID is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incomplete arguments. Expected mid and tags but only found &#34; + (
                         &#34;usertags&#34; if modelID is None else &#34;modelID&#34;)},
                &#39;data&#39;: None
            }), 400

    if type(userTags) == str:
        userTags = list(userTags.split(delim))
    elif type(userTags) != list:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Wrong format for tags. Allowed formats are either string or lists in square brackets.&#34;},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    tagsFromDB = con.getTags(modelID=modelID)

    relatedTags = getSuggestedTags(userTags, tagsFromDB, returnNumber)

    return jsonify(
        {
            &#39;status&#39;: RETURN_SUCCESS_STATUS,
            &#39;data&#39;: {&#34;tags&#34;: userTags,
                     &#34;mid&#34;: modelID,
                     &#34;suggested&#34;: relatedTags,
                     &#34;howMany&#34;: returnNumber}
        }), 200


@app.route(&#39;/api/train&#39;, methods=[&#39;POST&#39;])
def processTeach():
    &#34;&#34;&#34;
    Teaches the model with new knowledge.

    Required params:\n
    -action = &#39;teach&#39;\n
    -stoken\n
    -datatype =&gt; text or blob\n
    -data =&gt; raw text or base64 blob\n
    -sentiment =&gt; &#39;positive&#39;, &#39;negative&#39; or &#39;neutral&#39;\n
    -tags =&gt; list of tags\n
    :return: A success message and 201
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    noMissingData, data = getRequiredParameters(request, stoken=&#39;&#39;, action=&#39;&#39;, datatype=&#39;&#39;, data=&#39;&#39;, sentiment=&#39;&#39;, tags=&#39;&#39;)

    if not noMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    userID = con.checkToken(data[&#39;stoken&#39;])

    if userID == -1:
        return jsonify(INVALID_SESSION_TOKEN), 403

    if data[&#39;action&#39;] != &#34;teach&#34;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for teach.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if data[&#39;datatype&#39;] != &#39;text&#39; and data[&#39;datatype&#39;] != &#39;blob&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {
                        &#39;message&#39;: &#39;Wrong datatype. This endpoint only accepts raw text as \&#39;text\&#39; and pdf or txt files as \&#39;blob\&#39;.&#39;,
                        &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if data[&#39;datatype&#39;] == &#39;text&#39;:
        txtdata = str(data[&#39;data&#39;])
        tags = data[&#39;tags&#39;]
        sentiment = data[&#39;sentiment&#39;]

        # remove escape characters, if any
        if type(txtdata) is str:
            txtdata = txtdata.replace(&#34;\\&#34;, &#34;&#34;)

        if sentiment not in _labelAll:
            return jsonify(
                {
                    &#39;status&#39;:
                        {
                            &#39;message&#39;: &#34;Error in sentiments.&#34;,
                            &#39;error&#39;: True
                        },
                    &#39;data&#39;: None
                }), 400

        if con.getModelInfo(str(userID)) == [None, None]:
            return jsonify(
                {
                    &#39;status&#39;:
                        {
                            &#39;message&#39;: &#34;No model created yet.&#34;,
                            &#39;error&#39;: True
                        },
                    &#39;data&#39;: None
                }), 400

        modelID, modelName = con.getModelInfo(str(userID))
        model = Classifier(makeNewModel=False, modelName=modelName)
        processedText = model.train(text=txtdata, sentiment=data[&#39;sentiment&#39;], returnProcessedText=True)

        con.addNewTraining(modelID=modelID, tags=tags, sentiment=data[&#39;sentiment&#39;], processedText=processedText,
                           rawText=txtdata)

        return jsonify(
            {
                &#39;status&#39;: RETURN_SUCCESS_STATUS,
                &#39;data&#39;: None
            }), 201
    elif data[&#39;datatype&#39;] == &#39;blob&#39;:
        if type(data[&#39;data&#39;]) != list and type(data[&#39;data&#39;]) != str:
            return jsonify(
                {
                    &#39;status&#39;:
                        {&#39;error&#39;: True,
                         &#39;message&#39;: &#39;Data in the \&#39;data\&#39; field should be sent as a string or a list of items.&#39;},
                    &#39;data&#39;: None
                }), 400

        if type(data[&#39;data&#39;]) == list:  # if multiple files
            status, files = list(), list()
            for item in data[&#39;data&#39;]:
                filename = str(uuid.uuid4())  # generate temp file name
                # retval is the filename when iferr = False or the error message when iferr = True
                iferr, retval = getFileBase64(item, filename, userID)

                # in case file received is not a text-based (.pdf/.txt) file
                if not retval.endswith(&#39;pdf&#39;) and not retval.endswith(&#39;txt&#39;):
                    return jsonify(
                        {
                            &#39;status&#39;:
                                {&#39;error&#39;: True,
                                 &#39;message&#39;: &#34;Wrong format for data.&#34;},
                            &#39;data&#39;: None
                        }), 400

                status.append(iferr)
                files.append(retval)

            if False in status:  # if any error during converting the file
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: False,
                             &#39;message&#39;: ERRORFILEEXTEN}
                    }), 400

            modelID, modelName = con.getModelInfo(str(userID))
            model = Classifier(makeNewModel=False, modelName=modelName)

            tags = data[&#39;tags&#39;]

            # get text for each file
            for eachFile in files:
                txtdata = readTextFileContents(eachFile, return_metadata=False)
                os.remove(eachFile)  # remove temp file
                processedText = model.train(text=txtdata, sentiment=data[&#39;sentiment&#39;], returnProcessedText=True)
                con.addNewTraining(modelID=modelID, tags=tags, sentiment=data[&#39;sentiment&#39;],
                                   processedText=processedText, rawText=txtdata)

            return jsonify(
                {
                    &#39;status&#39;: RETURN_SUCCESS_STATUS,
                    &#39;data&#39;: None
                }), 201
        elif type(data[&#39;data&#39;]) == str:  # if single file
            filename = str(uuid.uuid4())  # generate temp file name
            status, filepath = getFileBase64(request.json[&#39;data&#39;], filename, userID)

            # in case file received is not a text-based (.pdf/.txt) file
            if not filepath.endswith(&#39;pdf&#39;) and not filepath.endswith(&#39;txt&#39;):
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: True,
                             &#39;message&#39;: &#34;Wrong format for data.&#34;},
                        &#39;data&#39;: None
                    }), 400

            if not status:
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: True,
                             &#39;message&#39;: ERRORFILEEXTEN},
                        &#39;data&#39;: None
                    }), 400

            modelID, modelName = con.getModelInfo(str(userID))
            model = Classifier(makeNewModel=False, modelName=modelName)

            tags = data[&#39;tags&#39;]

            txtdata = readTextFileContents(filepath, return_metadata=False)
            os.remove(filepath)  # remove temp file
            processedText = model.train(text=txtdata, sentiment=data[&#39;sentiment&#39;],
                                        returnProcessedText=True)
            con.addNewTraining(modelID=modelID, tags=tags, sentiment=data[&#39;sentiment&#39;],
                               processedText=processedText, rawText=txtdata)
            return jsonify(
                {
                    &#39;status&#39;: RETURN_SUCCESS_STATUS,
                    &#39;data&#39;: None
                }), 200


@app.route(&#39;/api/predict&#39;, methods=[&#39;POST&#39;])
def processAsk():
    &#34;&#34;&#34;
    Gets a prediction from the model.

    Required params:\n
    -action = &#39;ask&#39;\n
    -stoken\n
    -datatype =&gt; text or blob\n
    -data =&gt; raw text or base64 blob\n
    -tags =&gt; list of tags\n
    :return: The predicted sentiment, related tags and the original submitted text and 201
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    noMissingData, data = getRequiredParameters(request, stoken=&#39;&#39;, action=&#39;&#39;, datatype=&#39;&#39;, data=&#39;&#39;, tags=&#39;&#39;)

    if not noMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    userID = con.checkToken(data[&#39;stoken&#39;])

    if userID == -1:
        return jsonify(INVALID_SESSION_TOKEN), 403

    if data[&#39;action&#39;] != &#34;ask&#34;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for teach.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if data[&#39;datatype&#39;] != &#39;text&#39; and data[&#39;datatype&#39;] != &#39;blob&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {
                        &#39;message&#39;: &#39;Wrong datatype. This endpoint only accepts raw text as \&#39;text\&#39; and pdf or txt files as \&#39;blob\&#39;.&#39;,
                        &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if data[&#39;datatype&#39;] == &#39;text&#39;:
        txtdata = str(request.json[&#39;data&#39;])

        # remove escape characters, if any
        txtdata = txtdata.replace(&#34;\\&#34;, &#34;&#34;)

        if con.getModelInfo(str(userID)) == [None, None]:
            return jsonify(
                {
                    &#39;status&#39;:
                        {
                            &#39;message&#39;: &#34;No model created yet.&#34;,
                            &#39;error&#39;: True
                        },
                    &#39;data&#39;: None
                }), 400

        modelID, modelName = con.getModelInfo(str(userID))
        model = Classifier(makeNewModel=False, modelName=modelName)

        predSentiment = model.predict(txtdata)

        # get related tags
        userTags = request.json[&#39;tags&#39;]
        returnNumber = request.args.get(&#34;howMany&#34;) if request.args.get(
            &#34;howMany&#34;) is not None else DEFAULT_RETURN_SUGGESTED_TAGS
        delim = request.args.get(&#34;delim&#34;) if request.args.get(&#34;delim&#34;) is not None else &#34;,&#34;

        if type(userTags) == str:
            userTags = list(userTags.split(delim))
        elif type(userTags) != list:
            return jsonify(
                {
                    &#39;status&#39;:
                        {&#39;error&#39;: True,
                         &#39;message&#39;: &#34;Wrong format for tags. Allowed formats are either string or lists in square brackets.&#34;},
                    &#39;data&#39;: None
                }), 400

        tagsFromDB = con.getTags(modelID=modelID)
        relatedTags = getSuggestedTags(userTags, tagsFromDB, returnNumber)

        return jsonify(
            {
                &#39;status&#39;: RETURN_SUCCESS_STATUS,
                &#39;data&#39;:
                    {
                        &#39;predictedSentiment&#39;: predSentiment,
                        &#39;suggested&#39;: relatedTags,
                        &#39;text&#39;: txtdata
                    }
            }), 200
    elif data[&#39;datatype&#39;] == &#39;blob&#39;:
        if type(data[&#39;data&#39;]) != list and type(data[&#39;data&#39;]) != str:
            return jsonify(
                {
                    &#39;status&#39;:
                        {&#39;error&#39;: True,
                         &#39;message&#39;: &#39;Data in the \&#39;data\&#39; field should be sent as a string or a list of items.&#39;},
                    &#39;data&#39;: None
                }), 400

        if type(data[&#39;data&#39;]) == list:  # if multiple files
            modelID, modelName = con.getModelInfo(str(userID))
            model = Classifier(makeNewModel=False, modelName=modelName)

            predSentiment = list()
            for item in data[&#39;data&#39;]:
                filename = str(uuid.uuid4())  # generate temp file name
                status, filepath = getFileBase64(item, filename)

                # in case file received is not a text-based (.pdf/.txt) file
                if not filepath.endswith(&#39;pdf&#39;) and not filepath.endswith(&#39;txt&#39;):
                    os.remove(filepath)
                    return jsonify(
                        {
                            &#39;status&#39;:
                                {&#39;error&#39;: True,
                                 &#39;message&#39;: &#34;Wrong format for data.&#34;},
                            &#39;data&#39;: None
                        }), 400

                if not status:
                    return jsonify(
                        {
                            &#39;status&#39;:
                                {&#39;error&#39;: False,
                                 &#39;message&#39;: ERRORFILEEXTEN}
                        }), 400

                textData = readTextFileContents(filepath)
                predSentiment.append(model.predict(textData))
                os.remove(filepath)

            # get related tags
            userTags = data[&#39;tags&#39;]
            returnNumber = request.args.get(&#34;howMany&#34;) if request.args.get(
                &#34;howMany&#34;) is not None else DEFAULT_RETURN_SUGGESTED_TAGS
            delim = request.args.get(&#34;delim&#34;) if request.args.get(&#34;delim&#34;) is not None else &#34;,&#34;

            if type(userTags) == str:
                userTags = list(userTags.split(delim))
            elif type(userTags) != list:
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: True,
                             &#39;message&#39;: &#34;Wrong format for tags. Allowed formats are either string or lists in square brackets.&#34;},
                        &#39;data&#39;: None
                    }), 400

            tagsFromDB = con.getTags(modelID=modelID)
            relatedTags = getSuggestedTags(userTags, tagsFromDB, returnNumber)
            return jsonify(
                {
                    &#39;status&#39;: RETURN_SUCCESS_STATUS,
                    &#39;data&#39;:
                        {&#39;predictedSentiment&#39;: predSentiment,
                         &#39;suggested&#39;: relatedTags,
                         &#39;text&#39;: data[&#39;data&#39;]}
                }), 200
        elif type(data[&#39;data&#39;]) == str:  # if single file
            modelID, modelName = con.getModelInfo(str(userID))
            model = Classifier(makeNewModel=False, modelName=modelName)

            filename = str(uuid.uuid4())  # generate temp file name
            status, filepath = getFileBase64(data[&#39;data&#39;], filename)

            # in case file received is not a text-based (.pdf/.txt) file
            if not filepath.endswith(&#39;pdf&#39;) and not filepath.endswith(&#39;txt&#39;):
                os.remove(filepath)
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: True,
                             &#39;message&#39;: &#34;Wrong format for data.&#34;},
                        &#39;data&#39;: None
                    }), 400

            textData = readTextFileContents(filepath)
            os.remove(filepath)

            predSentiment = model.predict(textData)

            # get related tags
            userTags = data[&#39;tags&#39;]
            returnNumber = request.args.get(&#34;howMany&#34;) if request.args.get(
                &#34;howMany&#34;) is not None else DEFAULT_RETURN_SUGGESTED_TAGS
            delim = request.args.get(&#34;delim&#34;) if request.args.get(&#34;delim&#34;) is not None else &#34;,&#34;

            if type(userTags) == str:
                userTags = list(userTags.split(delim))
            elif type(userTags) != list:
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: True,
                             &#39;message&#39;: &#34;Wrong format for tags. Allowed formats are either string or lists in square brackets.&#34;},
                        &#39;data&#39;: None
                    }), 400

            tagsFromDB = con.getTags(modelID=modelID)
            relatedTags = getSuggestedTags(userTags, tagsFromDB, returnNumber)
            return jsonify(
                {
                    &#39;status&#39;: RETURN_SUCCESS_STATUS,
                    &#39;data&#39;:
                        {&#39;predictedSentiment&#39;: predSentiment,
                         &#39;suggested&#39;: relatedTags,
                         &#39;text&#39;: data[&#39;text&#39;]}
                }), 200


if __name__ == &#39;__main__&#39;:
    if fileExists(&#34;./Files/tika.pdf&#34;):
        readTextFileContents(&#34;./Files/tika.pdf&#34;)

    app.run(host=&#34;0.0.0.0&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="api.getOCRtext"><code class="name flex">
<span>def <span class="ident">getOCRtext</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets extracted text for an image.</p>
<p>Required params:</p>
<p>-action = 'ocr'</p>
<p>-stoken</p>
<p>-datatype = blob</p>
<p>-data =&gt; list (if multiple) or string (if single)</p>
<p>:return: Returns the extracted text and 200.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/api/ocr&#39;, methods=[&#39;POST&#39;])
def getOCRtext():
    &#34;&#34;&#34;
    Gets extracted text for an image.

    Required params:\n
    -action = &#39;ocr&#39;\n
    -stoken\n
    -datatype = blob\n
    -data =&gt; list (if multiple) or string (if single)\n

    :return: Returns the extracted text and 200.
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    noMissingData, data = getRequiredParameters(request, stoken=&#39;&#39;, datatype=&#39;&#39;, data=&#39;&#39;, action=&#39;&#39;)

    if not noMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    userID = con.checkToken(data[&#39;stoken&#39;])

    if userID == -1:
        return jsonify(INVALID_SESSION_TOKEN), 403

    if data[&#39;action&#39;] != &#39;ocr&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for getting OCR text.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if data[&#39;datatype&#39;] != &#39;blob&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong request. This endpoint is only for blobs.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if type(data[&#39;data&#39;]) != list and type(data[&#39;data&#39;]) != str:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong data type for \&#39;data\&#39; field. Accepted types are str or list.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    if type(data[&#39;data&#39;]) == list:  # if multiple files
        status, files = [], []
        for item in data[&#39;data&#39;]:
            filename = str(uuid.uuid4())  # generate temp file name
            iferr, retval = getFileBase64(item, filename, userID)
            status.append(iferr)
            files.append(retval)

        if False in status:  # if any error during converting the file
            return jsonify(
                {
                    &#39;status&#39;:
                        {&#39;error&#39;: False,
                         &#39;message&#39;: ERRORFILEEXTEN}
                }), 400

        ocrtext = []
        for eachFile in files:
            ocrtext.append(getOcr(eachFile))
            os.remove(eachFile)

        return jsonify(
            {
                &#39;status&#39;: RETURN_SUCCESS_STATUS,
                &#39;data&#39;:
                    {
                        &#39;ocrtext&#39;: ocrtext,
                        &#39;type&#39;: &#39;list&#39;}
            }), 200

    elif type(data[&#39;data&#39;]) == str:  # if single file
        filename = str(uuid.uuid4())  # generate temp file name
        status, filepath = getFileBase64(request.json[&#39;data&#39;], filename, userID)

        if not status:
            # if error during converting the file
            return jsonify(
                {
                    &#39;status&#39;:
                        {&#39;error&#39;: False,
                         &#39;message&#39;: ERRORFILEEXTEN}
                }), 400

        ocrtext = getOcr(filepath)
        os.remove(filepath)  # remove temp file
        return jsonify(
            {
                &#39;status&#39;: RETURN_SUCCESS_STATUS,
                &#39;data&#39;:
                    {
                        &#39;ocrtext&#39;: ocrtext,
                        &#39;type&#39;: &#39;str&#39;}
            }), 200</code></pre>
</details>
</dd>
<dt id="api.getRequiredParameters"><code class="name flex">
<span>def <span class="ident">getRequiredParameters</span></span>(<span>_request, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the request body contains all the required parameters. Uses a hack with **kwargs.</p>
<p>:param _request: The request body.
:param kwargs: The required parameters.
:return: Returns False and the parameter that was missing if there was missing data. Returns True and a dict containing all the parameter name and their values if successful.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRequiredParameters(_request, **kwargs):
    &#34;&#34;&#34;
    Checks if the request body contains all the required parameters. Uses a hack with **kwargs.

    :param _request: The request body.
    :param kwargs: The required parameters.
    :return: Returns False and the parameter that was missing if there was missing data. Returns True and a dict containing all the parameter name and their values if successful.
    &#34;&#34;&#34;
    if hasattr(_request, &#34;json&#34;):
        requestReceived = _request.json
    else:
        requestReceived = _request

    for key, value in kwargs.items():
        kwargs[key] = requestReceived.get(key)

    if None in kwargs.values():  # if one parameter is missing
        return [False, getDictKey(kwargs, kwargs.get(None))]
    else:
        return [True, kwargs]</code></pre>
</details>
</dd>
<dt id="api.getTags"><code class="name flex">
<span>def <span class="ident">getTags</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets suggested tags.</p>
<p>Required params:</p>
<p>-tags =&gt; list of tags, separated by a delimiter (default commas)
-mid =&gt; model ID</p>
<p>Optional params:</p>
<p>-howMany =&gt; default 5
-delim =&gt; default comma, used to separate the tags
:return: Suggested tags based on previous taught knowledge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/api/suggestedTags&#39;, methods=[&#39;GET&#39;])
def getTags():
    &#34;&#34;&#34;
    Gets suggested tags.

    Required params:\n
    -tags =&gt; list of tags, separated by a delimiter (default commas)
    -mid =&gt; model ID

    Optional params:\n
    -howMany =&gt; default 5
    -delim =&gt; default comma, used to separate the tags
    :return: Suggested tags based on previous taught knowledge.
    &#34;&#34;&#34;
    request.get_data()
    if request.args is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;No data is received.&#34;},
                &#39;data&#39;: None
            }), 400

    userTags = request.args.get(&#34;tags&#34;)
    modelID = request.args.get(&#34;mid&#34;)
    returnNumber = request.args.get(&#34;howMany&#34;) if request.args.get(&#34;howMany&#34;) is not None and int(
        request.args.get(&#34;howMany&#34;)) &gt; 0 else DEFAULT_RETURN_SUGGESTED_TAGS
    delim = request.args.get(&#34;delim&#34;) if request.args.get(&#34;delim&#34;) is not None else &#34;,&#34;

    if userTags is None or modelID is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incomplete arguments. Expected mid and tags but only found &#34; + (
                         &#34;usertags&#34; if modelID is None else &#34;modelID&#34;)},
                &#39;data&#39;: None
            }), 400

    if type(userTags) == str:
        userTags = list(userTags.split(delim))
    elif type(userTags) != list:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Wrong format for tags. Allowed formats are either string or lists in square brackets.&#34;},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    tagsFromDB = con.getTags(modelID=modelID)

    relatedTags = getSuggestedTags(userTags, tagsFromDB, returnNumber)

    return jsonify(
        {
            &#39;status&#39;: RETURN_SUCCESS_STATUS,
            &#39;data&#39;: {&#34;tags&#34;: userTags,
                     &#34;mid&#34;: modelID,
                     &#34;suggested&#34;: relatedTags,
                     &#34;howMany&#34;: returnNumber}
        }), 200</code></pre>
</details>
</dd>
<dt id="api.getTrainingData"><code class="name flex">
<span>def <span class="ident">getTrainingData</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all the available training data.</p>
<p>Required params:</p>
<p>-action = 'getData'</p>
<p>-stoken</p>
<p>:return: Returns the training data for that user and 200.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/api/training&#39;, methods=[&#39;POST&#39;])
def getTrainingData():
    &#34;&#34;&#34;
    Gets all the available training data.

    Required params:\n
    -action = &#39;getData&#39;\n
    -stoken\n

    :return: Returns the training data for that user and 200.
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    chkMissingData, data = getRequiredParameters(request, stoken=&#39;&#39;, action=&#39;&#39;)

    if not chkMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    userID = con.checkToken(data[&#34;stoken&#34;])

    if userID == -1:
        return jsonify(INVALID_SESSION_TOKEN), 403

    if data[&#39;action&#39;] != &#39;getData&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for retrieving training data.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    modelID, modelName = con.getModelInfo(str(userID))

    availableTraining = con.getAvailableTraining(modelID)

    formattedTraining = list()
    for item in availableTraining:
        trainingDict = dict()
        trainingDict[&#34;id&#34;] = item[0]
        trainingDict[&#34;rawText&#34;] = item[1]
        trainingDict[&#34;sentiment&#34;] = item[3]
        trainingDict[&#34;tags&#34;] = item[4]
        trainingDict[&#34;dateTrained&#34;] = item[5]
        formattedTraining.append(trainingDict)

    return jsonify(
        {
            &#39;status&#39;: RETURN_SUCCESS_STATUS,
            &#39;data&#39;:
                {
                    &#39;availableTraining&#39;: formattedTraining}
        }), 200</code></pre>
</details>
</dd>
<dt id="api.login"><code class="name flex">
<span>def <span class="ident">login</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks user's credentials and if successful, returns a session token lasting 3 hours for the user.</p>
<p>Required params:</p>
<p>-action = 'login'</p>
<p>-username</p>
<p>-userpw</p>
<p>:return: A session token and 201 if successful.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/api/login&#39;, methods=[&#39;POST&#39;])
def login():
    &#34;&#34;&#34;
    Checks user&#39;s credentials and if successful, returns a session token lasting 3 hours for the user.

    Required params:\n
    -action = &#39;login&#39;\n
    -username\n
    -userpw\n

    :return: A session token and 201 if successful.
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    chkMissingData, data = getRequiredParameters(request, action=&#39;&#39;, username=&#39;&#39;, userpw=&#39;&#39;)

    if not chkMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    # assume password sent is always unhashed, unless specified
    data[&#39;hashed&#39;] = False
    if request.json[&#39;hashed&#39;] is not None and request.json[&#39;hashed&#39;]:
        data[&#39;hashed&#39;] = request.json[&#39;hashed&#39;]

    con = Conn()
    sessionToken = generateSessionToken()

    if con.userLogin(data[&#39;username&#39;], data[&#39;userpw&#39;], sessionToken, data[&#39;hashed&#39;]) == -1:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: False,
                     &#39;message&#39;: &#34;User login failed.&#34;},
                &#39;data&#39;: None
            }), 403

    return jsonify(
        {
            &#39;status&#39;: RETURN_SUCCESS_STATUS,
            &#39;data&#39;: {&#39;token&#39;: sessionToken}
        }), 201</code></pre>
</details>
</dd>
<dt id="api.processAsk"><code class="name flex">
<span>def <span class="ident">processAsk</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a prediction from the model.</p>
<p>Required params:</p>
<p>-action = 'ask'</p>
<p>-stoken</p>
<p>-datatype =&gt; text or blob</p>
<p>-data =&gt; raw text or base64 blob</p>
<p>-tags =&gt; list of tags</p>
<p>:return: The predicted sentiment, related tags and the original submitted text and 201</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/api/predict&#39;, methods=[&#39;POST&#39;])
def processAsk():
    &#34;&#34;&#34;
    Gets a prediction from the model.

    Required params:\n
    -action = &#39;ask&#39;\n
    -stoken\n
    -datatype =&gt; text or blob\n
    -data =&gt; raw text or base64 blob\n
    -tags =&gt; list of tags\n
    :return: The predicted sentiment, related tags and the original submitted text and 201
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    noMissingData, data = getRequiredParameters(request, stoken=&#39;&#39;, action=&#39;&#39;, datatype=&#39;&#39;, data=&#39;&#39;, tags=&#39;&#39;)

    if not noMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    userID = con.checkToken(data[&#39;stoken&#39;])

    if userID == -1:
        return jsonify(INVALID_SESSION_TOKEN), 403

    if data[&#39;action&#39;] != &#34;ask&#34;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for teach.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if data[&#39;datatype&#39;] != &#39;text&#39; and data[&#39;datatype&#39;] != &#39;blob&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {
                        &#39;message&#39;: &#39;Wrong datatype. This endpoint only accepts raw text as \&#39;text\&#39; and pdf or txt files as \&#39;blob\&#39;.&#39;,
                        &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if data[&#39;datatype&#39;] == &#39;text&#39;:
        txtdata = str(request.json[&#39;data&#39;])

        # remove escape characters, if any
        txtdata = txtdata.replace(&#34;\\&#34;, &#34;&#34;)

        if con.getModelInfo(str(userID)) == [None, None]:
            return jsonify(
                {
                    &#39;status&#39;:
                        {
                            &#39;message&#39;: &#34;No model created yet.&#34;,
                            &#39;error&#39;: True
                        },
                    &#39;data&#39;: None
                }), 400

        modelID, modelName = con.getModelInfo(str(userID))
        model = Classifier(makeNewModel=False, modelName=modelName)

        predSentiment = model.predict(txtdata)

        # get related tags
        userTags = request.json[&#39;tags&#39;]
        returnNumber = request.args.get(&#34;howMany&#34;) if request.args.get(
            &#34;howMany&#34;) is not None else DEFAULT_RETURN_SUGGESTED_TAGS
        delim = request.args.get(&#34;delim&#34;) if request.args.get(&#34;delim&#34;) is not None else &#34;,&#34;

        if type(userTags) == str:
            userTags = list(userTags.split(delim))
        elif type(userTags) != list:
            return jsonify(
                {
                    &#39;status&#39;:
                        {&#39;error&#39;: True,
                         &#39;message&#39;: &#34;Wrong format for tags. Allowed formats are either string or lists in square brackets.&#34;},
                    &#39;data&#39;: None
                }), 400

        tagsFromDB = con.getTags(modelID=modelID)
        relatedTags = getSuggestedTags(userTags, tagsFromDB, returnNumber)

        return jsonify(
            {
                &#39;status&#39;: RETURN_SUCCESS_STATUS,
                &#39;data&#39;:
                    {
                        &#39;predictedSentiment&#39;: predSentiment,
                        &#39;suggested&#39;: relatedTags,
                        &#39;text&#39;: txtdata
                    }
            }), 200
    elif data[&#39;datatype&#39;] == &#39;blob&#39;:
        if type(data[&#39;data&#39;]) != list and type(data[&#39;data&#39;]) != str:
            return jsonify(
                {
                    &#39;status&#39;:
                        {&#39;error&#39;: True,
                         &#39;message&#39;: &#39;Data in the \&#39;data\&#39; field should be sent as a string or a list of items.&#39;},
                    &#39;data&#39;: None
                }), 400

        if type(data[&#39;data&#39;]) == list:  # if multiple files
            modelID, modelName = con.getModelInfo(str(userID))
            model = Classifier(makeNewModel=False, modelName=modelName)

            predSentiment = list()
            for item in data[&#39;data&#39;]:
                filename = str(uuid.uuid4())  # generate temp file name
                status, filepath = getFileBase64(item, filename)

                # in case file received is not a text-based (.pdf/.txt) file
                if not filepath.endswith(&#39;pdf&#39;) and not filepath.endswith(&#39;txt&#39;):
                    os.remove(filepath)
                    return jsonify(
                        {
                            &#39;status&#39;:
                                {&#39;error&#39;: True,
                                 &#39;message&#39;: &#34;Wrong format for data.&#34;},
                            &#39;data&#39;: None
                        }), 400

                if not status:
                    return jsonify(
                        {
                            &#39;status&#39;:
                                {&#39;error&#39;: False,
                                 &#39;message&#39;: ERRORFILEEXTEN}
                        }), 400

                textData = readTextFileContents(filepath)
                predSentiment.append(model.predict(textData))
                os.remove(filepath)

            # get related tags
            userTags = data[&#39;tags&#39;]
            returnNumber = request.args.get(&#34;howMany&#34;) if request.args.get(
                &#34;howMany&#34;) is not None else DEFAULT_RETURN_SUGGESTED_TAGS
            delim = request.args.get(&#34;delim&#34;) if request.args.get(&#34;delim&#34;) is not None else &#34;,&#34;

            if type(userTags) == str:
                userTags = list(userTags.split(delim))
            elif type(userTags) != list:
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: True,
                             &#39;message&#39;: &#34;Wrong format for tags. Allowed formats are either string or lists in square brackets.&#34;},
                        &#39;data&#39;: None
                    }), 400

            tagsFromDB = con.getTags(modelID=modelID)
            relatedTags = getSuggestedTags(userTags, tagsFromDB, returnNumber)
            return jsonify(
                {
                    &#39;status&#39;: RETURN_SUCCESS_STATUS,
                    &#39;data&#39;:
                        {&#39;predictedSentiment&#39;: predSentiment,
                         &#39;suggested&#39;: relatedTags,
                         &#39;text&#39;: data[&#39;data&#39;]}
                }), 200
        elif type(data[&#39;data&#39;]) == str:  # if single file
            modelID, modelName = con.getModelInfo(str(userID))
            model = Classifier(makeNewModel=False, modelName=modelName)

            filename = str(uuid.uuid4())  # generate temp file name
            status, filepath = getFileBase64(data[&#39;data&#39;], filename)

            # in case file received is not a text-based (.pdf/.txt) file
            if not filepath.endswith(&#39;pdf&#39;) and not filepath.endswith(&#39;txt&#39;):
                os.remove(filepath)
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: True,
                             &#39;message&#39;: &#34;Wrong format for data.&#34;},
                        &#39;data&#39;: None
                    }), 400

            textData = readTextFileContents(filepath)
            os.remove(filepath)

            predSentiment = model.predict(textData)

            # get related tags
            userTags = data[&#39;tags&#39;]
            returnNumber = request.args.get(&#34;howMany&#34;) if request.args.get(
                &#34;howMany&#34;) is not None else DEFAULT_RETURN_SUGGESTED_TAGS
            delim = request.args.get(&#34;delim&#34;) if request.args.get(&#34;delim&#34;) is not None else &#34;,&#34;

            if type(userTags) == str:
                userTags = list(userTags.split(delim))
            elif type(userTags) != list:
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: True,
                             &#39;message&#39;: &#34;Wrong format for tags. Allowed formats are either string or lists in square brackets.&#34;},
                        &#39;data&#39;: None
                    }), 400

            tagsFromDB = con.getTags(modelID=modelID)
            relatedTags = getSuggestedTags(userTags, tagsFromDB, returnNumber)
            return jsonify(
                {
                    &#39;status&#39;: RETURN_SUCCESS_STATUS,
                    &#39;data&#39;:
                        {&#39;predictedSentiment&#39;: predSentiment,
                         &#39;suggested&#39;: relatedTags,
                         &#39;text&#39;: data[&#39;text&#39;]}
                }), 200</code></pre>
</details>
</dd>
<dt id="api.processTeach"><code class="name flex">
<span>def <span class="ident">processTeach</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Teaches the model with new knowledge.</p>
<p>Required params:</p>
<p>-action = 'teach'</p>
<p>-stoken</p>
<p>-datatype =&gt; text or blob</p>
<p>-data =&gt; raw text or base64 blob</p>
<p>-sentiment =&gt; 'positive', 'negative' or 'neutral'</p>
<p>-tags =&gt; list of tags</p>
<p>:return: A success message and 201</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/api/train&#39;, methods=[&#39;POST&#39;])
def processTeach():
    &#34;&#34;&#34;
    Teaches the model with new knowledge.

    Required params:\n
    -action = &#39;teach&#39;\n
    -stoken\n
    -datatype =&gt; text or blob\n
    -data =&gt; raw text or base64 blob\n
    -sentiment =&gt; &#39;positive&#39;, &#39;negative&#39; or &#39;neutral&#39;\n
    -tags =&gt; list of tags\n
    :return: A success message and 201
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    noMissingData, data = getRequiredParameters(request, stoken=&#39;&#39;, action=&#39;&#39;, datatype=&#39;&#39;, data=&#39;&#39;, sentiment=&#39;&#39;, tags=&#39;&#39;)

    if not noMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    userID = con.checkToken(data[&#39;stoken&#39;])

    if userID == -1:
        return jsonify(INVALID_SESSION_TOKEN), 403

    if data[&#39;action&#39;] != &#34;teach&#34;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for teach.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if data[&#39;datatype&#39;] != &#39;text&#39; and data[&#39;datatype&#39;] != &#39;blob&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {
                        &#39;message&#39;: &#39;Wrong datatype. This endpoint only accepts raw text as \&#39;text\&#39; and pdf or txt files as \&#39;blob\&#39;.&#39;,
                        &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if data[&#39;datatype&#39;] == &#39;text&#39;:
        txtdata = str(data[&#39;data&#39;])
        tags = data[&#39;tags&#39;]
        sentiment = data[&#39;sentiment&#39;]

        # remove escape characters, if any
        if type(txtdata) is str:
            txtdata = txtdata.replace(&#34;\\&#34;, &#34;&#34;)

        if sentiment not in _labelAll:
            return jsonify(
                {
                    &#39;status&#39;:
                        {
                            &#39;message&#39;: &#34;Error in sentiments.&#34;,
                            &#39;error&#39;: True
                        },
                    &#39;data&#39;: None
                }), 400

        if con.getModelInfo(str(userID)) == [None, None]:
            return jsonify(
                {
                    &#39;status&#39;:
                        {
                            &#39;message&#39;: &#34;No model created yet.&#34;,
                            &#39;error&#39;: True
                        },
                    &#39;data&#39;: None
                }), 400

        modelID, modelName = con.getModelInfo(str(userID))
        model = Classifier(makeNewModel=False, modelName=modelName)
        processedText = model.train(text=txtdata, sentiment=data[&#39;sentiment&#39;], returnProcessedText=True)

        con.addNewTraining(modelID=modelID, tags=tags, sentiment=data[&#39;sentiment&#39;], processedText=processedText,
                           rawText=txtdata)

        return jsonify(
            {
                &#39;status&#39;: RETURN_SUCCESS_STATUS,
                &#39;data&#39;: None
            }), 201
    elif data[&#39;datatype&#39;] == &#39;blob&#39;:
        if type(data[&#39;data&#39;]) != list and type(data[&#39;data&#39;]) != str:
            return jsonify(
                {
                    &#39;status&#39;:
                        {&#39;error&#39;: True,
                         &#39;message&#39;: &#39;Data in the \&#39;data\&#39; field should be sent as a string or a list of items.&#39;},
                    &#39;data&#39;: None
                }), 400

        if type(data[&#39;data&#39;]) == list:  # if multiple files
            status, files = list(), list()
            for item in data[&#39;data&#39;]:
                filename = str(uuid.uuid4())  # generate temp file name
                # retval is the filename when iferr = False or the error message when iferr = True
                iferr, retval = getFileBase64(item, filename, userID)

                # in case file received is not a text-based (.pdf/.txt) file
                if not retval.endswith(&#39;pdf&#39;) and not retval.endswith(&#39;txt&#39;):
                    return jsonify(
                        {
                            &#39;status&#39;:
                                {&#39;error&#39;: True,
                                 &#39;message&#39;: &#34;Wrong format for data.&#34;},
                            &#39;data&#39;: None
                        }), 400

                status.append(iferr)
                files.append(retval)

            if False in status:  # if any error during converting the file
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: False,
                             &#39;message&#39;: ERRORFILEEXTEN}
                    }), 400

            modelID, modelName = con.getModelInfo(str(userID))
            model = Classifier(makeNewModel=False, modelName=modelName)

            tags = data[&#39;tags&#39;]

            # get text for each file
            for eachFile in files:
                txtdata = readTextFileContents(eachFile, return_metadata=False)
                os.remove(eachFile)  # remove temp file
                processedText = model.train(text=txtdata, sentiment=data[&#39;sentiment&#39;], returnProcessedText=True)
                con.addNewTraining(modelID=modelID, tags=tags, sentiment=data[&#39;sentiment&#39;],
                                   processedText=processedText, rawText=txtdata)

            return jsonify(
                {
                    &#39;status&#39;: RETURN_SUCCESS_STATUS,
                    &#39;data&#39;: None
                }), 201
        elif type(data[&#39;data&#39;]) == str:  # if single file
            filename = str(uuid.uuid4())  # generate temp file name
            status, filepath = getFileBase64(request.json[&#39;data&#39;], filename, userID)

            # in case file received is not a text-based (.pdf/.txt) file
            if not filepath.endswith(&#39;pdf&#39;) and not filepath.endswith(&#39;txt&#39;):
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: True,
                             &#39;message&#39;: &#34;Wrong format for data.&#34;},
                        &#39;data&#39;: None
                    }), 400

            if not status:
                return jsonify(
                    {
                        &#39;status&#39;:
                            {&#39;error&#39;: True,
                             &#39;message&#39;: ERRORFILEEXTEN},
                        &#39;data&#39;: None
                    }), 400

            modelID, modelName = con.getModelInfo(str(userID))
            model = Classifier(makeNewModel=False, modelName=modelName)

            tags = data[&#39;tags&#39;]

            txtdata = readTextFileContents(filepath, return_metadata=False)
            os.remove(filepath)  # remove temp file
            processedText = model.train(text=txtdata, sentiment=data[&#39;sentiment&#39;],
                                        returnProcessedText=True)
            con.addNewTraining(modelID=modelID, tags=tags, sentiment=data[&#39;sentiment&#39;],
                               processedText=processedText, rawText=txtdata)
            return jsonify(
                {
                    &#39;status&#39;: RETURN_SUCCESS_STATUS,
                    &#39;data&#39;: None
                }), 200</code></pre>
</details>
</dd>
<dt id="api.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Registers a user and creates a model for them.</p>
<p>Required params:</p>
<p>-action = 'register'</p>
<p>-username</p>
<p>-userpw</p>
<p>-email</p>
<p>-firstname</p>
<p>-lastname</p>
<p>:return: Returns the modelID and 201 for them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/api/registration&#39;, methods=[&#39;POST&#39;])
def register():
    &#34;&#34;&#34;
    Registers a user and creates a model for them.

    Required params:\n
    -action = &#39;register&#39;\n
    -username\n
    -userpw\n
    -email\n
    -firstname\n
    -lastname\n
    :return: Returns the modelID and 201 for them.
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    chkMissingData, data = getRequiredParameters(request, action=&#39;&#39;, username=&#39;&#39;, userpw=&#39;&#39;, email=&#39;&#39;,
                                                 firstname=&#39;&#39;, lastname=&#39;&#39;)

    if not chkMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()

    if data[&#39;action&#39;] != &#39;register&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for registration.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    username = data[&#34;username&#34;]
    password = data[&#34;userpw&#34;]  # assume plain password sent over https

    if con.usernameExists(username):
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Username already exists.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    userID = con.registerUser(username=username, pwd=password, firstName=data[&#39;firstname&#39;], lastName=data[&#39;lastname&#39;],
                              email=data[&#39;email&#39;], usePwHash=False)

    # make new model
    model = Classifier(makeNewModel=True)
    mid = con.addNewModel(userID=str(userID), modelName=model.modelName)

    # if error during user creation
    if userID == -1 or mid == -1:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Server encountered error with user registration. Please try again later&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 500

    # if user registration is ok
    return jsonify(
        {
            &#39;status&#39;: RETURN_SUCCESS_STATUS,
            &#39;data&#39;: {&#39;mid&#39;: mid}
        }), 201</code></pre>
</details>
</dd>
<dt id="api.retrain"><code class="name flex">
<span>def <span class="ident">retrain</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to retrain the model.</p>
<p>Required params:</p>
<p>-action = 'retrain'</p>
<p>-stoken =&gt; the session token </p>
<p>-data =&gt; a list of trainingID that will be deleted</p>
<p>:return: A success message and 200.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/api/retrain&#39;, methods=[&#39;PUT&#39;])
def retrain():
    &#34;&#34;&#34;
    Used to retrain the model.

    Required params:\n
    -action = &#39;retrain&#39;\n
    -stoken =&gt; the session token \n
    -data =&gt; a list of trainingID that will be deleted\n

    :return: A success message and 200.
    &#34;&#34;&#34;
    request.get_data()
    if request.json is None:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;error&#39;: True,
                     &#39;message&#39;: &#34;Incorrect header type. Header type should be application/json.&#34;},
                &#39;data&#39;: None
            }), 400

    chkMissingData, data = getRequiredParameters(request, stoken=&#39;&#39;, action=&#39;&#39;, data=&#39;&#39;)

    if not chkMissingData:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Missing required parameter \&#39;&#39; + data + &#39;\&#39;&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    con = Conn()
    userID = con.checkToken(data[&#34;stoken&#34;])

    if userID == -1:
        return jsonify(INVALID_SESSION_TOKEN), 403

    if data[&#39;action&#39;] != &#39;retrain&#39;:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Wrong action. This endpoint is only for retraining.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 403

    if type(data[&#39;data&#39;]) != list:
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Bad data. Data in the \&#39;data\&#39; field must be sent as list.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 400

    # get old model info
    oldModelID, oldModelName = con.getModelInfo(str(userID))

    if not con.removeTraining(oldModelID, data[&#39;data&#39;]):
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Internal server encountered. Please try again.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 500

    availableTraining = con.getAvailableTraining(oldModelID)

    # make a new model
    model = Classifier(makeNewModel=True)
    for eachData in availableTraining:
        model.train(text=eachData[2], sentiment=eachData[3], fromDB=True)

    # update db with new model info
    if not con.updateModelInfo(oldModelID, modelName=model.modelName):
        return jsonify(
            {
                &#39;status&#39;:
                    {&#39;message&#39;: &#39;Internal server error when updating the resource.&#39;,
                     &#39;error&#39;: True},
                &#39;data&#39;: None
            }), 500

    if not oldModelName.endswith(PICKLE_FILE_EXTENSION):
        oldModelName += PICKLE_FILE_EXTENSION

    os.remove(os.path.join(os.path.dirname(__file__), &#39;Models/&#39; + oldModelName))

    return jsonify(
        {
            &#39;status&#39;:
                {&#39;message&#39;: &#39;Model successfully retrained.&#39;,
                 &#39;error&#39;: False},
            &#39;data&#39;: None
        }), 200</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="api.getOCRtext" href="#api.getOCRtext">getOCRtext</a></code></li>
<li><code><a title="api.getRequiredParameters" href="#api.getRequiredParameters">getRequiredParameters</a></code></li>
<li><code><a title="api.getTags" href="#api.getTags">getTags</a></code></li>
<li><code><a title="api.getTrainingData" href="#api.getTrainingData">getTrainingData</a></code></li>
<li><code><a title="api.login" href="#api.login">login</a></code></li>
<li><code><a title="api.processAsk" href="#api.processAsk">processAsk</a></code></li>
<li><code><a title="api.processTeach" href="#api.processTeach">processTeach</a></code></li>
<li><code><a title="api.register" href="#api.register">register</a></code></li>
<li><code><a title="api.retrain" href="#api.retrain">retrain</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>